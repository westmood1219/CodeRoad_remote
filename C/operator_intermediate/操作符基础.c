#include <stdio.h>
//移位操作符：
//下面介绍整数的左移

//整数的二进制表示有三种：原码，反码，补码
//对于7（正整数）
//00000000000000000000000000000111 - 原码
//00000000000000000000000000000111 - 反码
//00000000000000000000000000000111 - 补码
// 正整数的原、反、补码相同
// 
//对于-7（负整数）
//10000000000000000000000000000111 - 原码
// 负整数的原码最前面的二进制数是1
//11111111111111111111111111111000 - 反码
// 负整数原码的符号位不变，其他位按位取反就是反码
//11111111111111111111111111111001 - 补码
//反码加1就是补码
//
//整数在内存中存储的就是补码，所以操作的也是反码
//int main()
//{
//    int a = -7;
//    int b = a << 1;
//    //左移操作符
//    //移动二进制位，左边不要了，右边空出来的地方补0
//    printf("a=%d\n", a);//-7
//    printf("b=%d\n", b);//-14
// 
//    return 0;
//}
//浮点数能不能左移？不能
//int main()
//{
//    float a = 3.14f;
//    float f2 = a << 1;//这里可以发现error左移操作符无法对浮点数左移
//    printf("a=%d\n", a);
//    printf("f2=%d\n", f2);//error:“ << ”: 无效，因为左操作数的类型为“float”
//    return 0;
//}
//左移后符号不变，绝对值变为原来的两倍。因为左移原理就是把对应的二进制数整体左移，2^0位递补成零，其他位进一位

//接下来讲右移操作符：
//右移操作符分两种：算术移位      逻辑移位
//算术移位：右边丢弃，左边补原符号位（多见）
//逻辑移位：右边丢弃，左边补零
//int main()
//{
//    int a = -7;
//    int b = a >> 1;
//    //右移操作符
//    //移动二进制位
//    printf("a=%d\n", a);//-7
//    printf("b=%d\n", b);//-4
//    //这里发现VS2022采用的是算术右移
//    return 0;
//}

//补充：移位操作符的位数不能用负数（这是C语言标准未定义行为）

//位操作符：

//& - 按（二进制）位与
//| - 按（二进制）位或
//^ - 按（二进制）位异或

//int main()
//{
//    int a = 3;//00000000000000000000000000000011 
//    int b = -5;//10000000000000000000000000000101
//    //00000000000000000000000000000011  3的补码
//    //11111111111111111111111111111011  -5的补码 
//    int c = a & b;//在内存里补码对应都为1，才为一，否则为零；全都对应下来后就是a & b的结果的补码
//    //00000000000000000000000000000011 
//    printf("c=%d\n", c);//
//    int d = a | b;//在内存里补码对应若有1，则为一，否则为零；全都对应下来后就是a | b的结果的补码
//    //10000000000000000000000000000101
//    printf("d=%d\n", d);//-5
//    int e = a ^ b;//相同为零，相异为一
//    //10000000000000000000000000001000
//    printf("e=%d\n", e);//-8
//    return 0;
//}

//练习题：求一个整数存储在内存中的二进制中1的个数
//用&的方法
//int main()
//{
//    int a = 3;//-7,3都可以！
//    int count = 0;
//    for (int i = 1; i <= 32; i++)
//    {
//        if (a & 1 == 1)//可以得出
//        {
//            count++;
//        }
//        a = a >> 1;
//    }
//    printf("%d\n", count);
//}
// 用|的方法（自己想的）
//int main()
//{
//    int a = 3;//-7,3都可以！
//    int count = 0;
//    for (int i = 1; i <= 32; i++)
//    {
//        if (a  < 0)//可以得出
//        {
//            count++;
//        }
//        a = a << 1;
//    }
//    printf("%d\n", count);
//}

//赋值操作符：=
//复合赋值操作符：
//-= +=・・・・・・上面的操作符后面接一个=就是复合赋值操作符了

//单目操作符：只有一个操作数
//!（逻辑取反） sizeof(计算变量或类型在内存中占用的字节)
//& - + ~（按二进制位取反） -- ++ *
//int main()
//{
//    int n = sizeof(unsigned int);
//    printf("n=%d\n", n);//4
//    int n = sizeof(unsigned char);
//    printf("n=%d\n", n);//1
//
//    int a = 0;
//    //补码：000000000000000000000000
//    //~a：111111111111111111111111
//    printf("%d\n", ~a);//-1
//    a = 13;
//    a |= (1 << 4);
//    pirntf("%d\n", a);//a=29
//    a = 13;
//    a &= (~(1 << 4));
//    pirntf("%d\n", a);//a=13
//
//    a = 3;
//    int b = ++a;//前置加加：先加加后使用
//    pirntf("%d\n", a);//4
//    pirntf("%d\n", b);//4
//    b = a++;//相反
//    pirntf("%d\n", a);//5
//    pirntf("%d\n", b);//4
//    printf("%d\n", a++);//5:在printf里也一样
//    printf("%d\n", a);//6
//    //test(a++);//甚至在函数里也一样（先传参再计算）
//
//    //*间接访问操作符（解引用操作符）
//    a = 10;
//    int* p = &a;
//    *p = 20;
//    printf("%d\n", a);//20
//    return 0;

    //强制类型转换
    /*int main()
    {
        int a = (int)3.14;不加（int）编译器会报警告，加了就是强制转化成了int
        printf("%d\n", a);
        srand((unsigned int)time(NULL));
        就是把long long int类型的time（）转换成了unsigned int
        return 0;
    }*/
//}

//sizeof后面的括号能不能去掉？
//int main()
//{
//    int a = 0;
//    printf("%d\n", sizeof a);//4
//    //说明sizeof是一个操作符，不是一个函数
//    //而strlen是一个函数，所以strlen后面的括号不能去掉
//    return 0;
//}

//void test1(int arr[]) {
//    printf("%d\n", sizeof(arr));//4:数组名是一个指针，所以是4个字节（而不是因为arr是指向int类型的指针所以和int类型一样大）
//}
//
//void test2(char ch[]) {
//    printf("%d\n", sizeof(ch));//4:同上（如果是64位系统就是8）
//}
//
//int main() {
//    int arr[10] = {0};
//    char ch[10] = {0};
//    printf("%d\n", sizeof(arr));//40:一个int占4个字节，所以10个int占40个字节
//    printf("%d\n", sizeof(ch));//10
//    test1(arr);
//    test2(ch);
//    return 0;
//}

//关系操作符：> < >= <= == !=
//没什么好说的
//有几个要注意的：浮点数比较时要注意精度问题所以不能直接用==来比较
//字符串比较时不能直接用==来比较，要用strcmp函数
//结构体比较时不能直接用==来比较，要用memcmp函数
// if ("abc" == "abcdef")这样是错误的，因为这样比较的是两个字符串的地址，而不是字符串的内容

//逻辑操作符：&& ||

//int main()
//{
//    int a = 3;
//    int b = 5;
//    int c = a && b;//逻辑与：两边都为真，结果为真,真为1，假为0
//    printf("c=%d\n", c);//1
//    c = a || b;//逻辑或：两边有一个为真，结果为真
//    printf("c=%d\n", c);//1
//    c = !a;//逻辑非：真为假，假为真
//    return 0;
//}

//int is_leap_year(int year) {
//    return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
//}

//int main()
//{
//    int i = 0, a = 0, b = 2, c = 3, d = 4;
//    i = a++ && ++b && d++;//从左到右，a++为后置运算所以用完a之后才++，而&&左边为假所以后面的计算机都不会计算了
//    //a++得看成是表达式，表达式用完之后++才会生效
//    printf("a=%d\nb=%d\nc=%d\nd=%d\n", a, b, c, d);//1,2,3,4
//
//    a = 1;
//    printf( "a=%d\nb=%d\nc=%d\nd=%d\n", a, b, c, d);
//
//    a = 1, b = 2, c = 3, d = 4;
//    i = a++ || ++b || d++;//从左到右，a++为后置运算所以用完a之后才++，而||左边为真所以后面的计算机都不会计算了
//    printf("a=%d\nb=%d\nc=%d\nd=%d\n", a, b, c, d);//2,2,3,4
//
//    a = 0;
//    i = a++ || ++b || d++;
//    printf("a=%d\nb=%d\nc=%d\nd=%d\n", a, b, c, d);//1,3,3,4
//    return 0;
//}
//summary:&&和||都是短路操作符，只要左边的表达式能够确定整个表达式的值，右边的表达式就不会执行

//条件操作符：表达式1？表达式2：表达式3
//原理：如果表达式1为真，整个表达式的值为表达式2，否则为表达式3
//int max = a > b ? a : b;

//逗号操作符：表达式1，表达式2，表达式3，・・・・・・
//原理：从左到右依次执行，整个表达式的值为最后一个表达式的值
//int main()
//{
//    int a = 0;
//    int b = 0;
//    int c = 0;
//    c = (a++, b++, a + b);//c=1+1=2
//    printf("c=%d\n", c);
//    return 0;
//}

//下标引用操作符：[]
//int main()
//{
//    int arr[10] = { 0 };
//    arr[7] = 8;//[]的操作数是一个数组名和一个整数，整数表示数组下标
//    7[arr] = 8;//这样也是可以的，因为a[b]等价于*(a+b)
//    return 0;
//}

////函数调用操作符：()
//int add(int x, int y) {
//    return x + y;
//}
//int main()
//{
//    int a = 3;
//    int b = 5;
//    int sum = add(a, b);//a和b不能没有()，因为()是函数调用操作符
//    //操作数：函数名和实参列表（实参列表可以为空）
//    sizeof a;//sizeof是一个操作符，不是一个函数，所以a后面的括号可以去掉
//    return 0;
//}

//结构体操作符：.
//#include <string.h>
//struct Stu
//{
//    char name[20];
//    int age;
//    char id[20];
//};
////void set_stu(struct Stu ss)//这样是错误的，因为set_stu函数的形参是一个结构体，是值传递，所以传进去的是一个副本
//void set_stu(struct Stu* ps)
//{
//    //ss.name = "zhangsan";
//    //ss.age = 20;
//    //ss.id = "123456";
//    //这样是错误的，因为name是一个地址，不能直接赋值
//    //正确的方法是用strcpy函数（字符串拷贝函数）
//    /*strcpy(ss.name, "zhangsan");*/
//    //strcpy((*ps).name, "zhangsan");//这样也是可以的但是繁琐
//    strcpy_s(ps->name,20, "zhangsan");
//    ps->age = 20;
//    strcpy_s(ps->id,20, "123456");
//}
//void print_stu(struct Stu ss)
//{
//    printf("%s\n", ss.name);
//    printf("%d\n", ss.age);
//    printf("%s\n", ss.id);
//}
//int main()
//{
//    struct Stu s = {0};
//    //set_stu(s);//这样是错误的，因为set_stu函数的形参是一个结构体，是值传递，所以传进去的是一个副本
//    set_stu(&s);
//    print_stu(s);
//    return 0;
//}